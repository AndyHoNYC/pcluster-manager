AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Pcluster Manager ECR with pull through cache

Parameters:
  PublicEcrImageUri:
    Description: When specified, the URI of the Docker image for the Lambda of the PclusterManager container
    Type: String
    Default: public.ecr.aws/n0x0o5k1/pcluster-manager:latest

Mappings:
  PclusterManager:
    Constants:
      Version: 3.1.1
      ShortVersion: 3.1.1

Resources:

  PipLayerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      Policies:
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                - logs:CreateLogGroup
                - logs:CreateLogStream
                - logs:PutLogEvents
                Effect: Allow
                Resource:
                  - !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/PipLayer-${AWS::StackName}:*
              - Action:
                - lambda:PublishLayerVersion
                - lambda:DeleteLayerVersion
                Effect: Allow
                Resource:
                  - "*"
          PolicyName: lambda

  PipLayerLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Create layers based on pip
      FunctionName: !Sub "PipLayer-${AWS::StackName}"
      Handler: index.handler
      MemorySize: 1024
      Role: !GetAtt PipLayerLambdaRole.Arn
      Runtime: python3.9
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import logging
          import pathlib
          import re
          import subprocess
          import sys
          import tempfile
          import typing as t
          import shutil
          import cfnresponse
          import boto3
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          class PipLayerException(Exception):
              pass
          def _create(properties) -> t.Tuple[str, t.Mapping[str, str]]:
              try:
                  layername = properties["LayerName"]
                  description = properties.get("Description", "PipLayer")
                  packages = properties["Packages"]
              except KeyError as e:
                  raise PipLayerException("Missing parameter: %s" % e.args[0])
              description += " ({})".format(", ".join(packages))
              if not isinstance(layername, str):
                  raise PipLayerException("LayerName must be a string")
              if not isinstance(description, str):
                  raise PipLayerException("Description must be a string")
              if not isinstance(packages, list) or not all(isinstance(p, str) for p in packages):
                  raise PipLayerException("Packages must be a list of strings")
              tempdir = pathlib.Path(tempfile.TemporaryDirectory().name) / "python"
              try:
                  subprocess.check_call([
                      sys.executable, "-m", "pip", "install", *packages, "-t", tempdir])
              except subprocess.CalledProcessError:
                  raise PipLayerException("Error while installing %s" % str(packages))
              zipfilename = pathlib.Path(tempfile.NamedTemporaryFile(suffix=".zip").name)
              shutil.make_archive(
                  zipfilename.with_suffix(""), format="zip", root_dir=tempdir.parent)
              client = boto3.client("lambda")
              layer = client.publish_layer_version(
                  LayerName=layername,
                  Description=description,
                  Content={"ZipFile": zipfilename.read_bytes()},
                  CompatibleRuntimes=["python%d.%d" % sys.version_info[:2]],
              )
              logger.info("Created layer %s", layer["LayerVersionArn"])
              return (layer["LayerVersionArn"], {})
          def _delete(physical_id):
              match = re.fullmatch(
                  r"arn:aws:lambda:(?P<region>[^:]+):(?P<account>\d+):layer:"
                  r"(?P<layername>[^:]+):(?P<version_number>\d+)", physical_id)
              if not match:
                  logger.warning("Cannot parse physical id %s, not deleting", physical_id)
                  return
              layername = match.group("layername")
              version_number = int(match.group("version_number"))
              logger.info("Now deleting layer %s:%d", layername, version_number)
              client = boto3.client("lambda")
              deletion = client.delete_layer_version(
                  LayerName=layername,
                  VersionNumber=version_number)
              logger.info("Done")
          def handler(event, context):
              logger.info('{"event": %s}', json.dumps(event))
              try:
                  if event["RequestType"].upper() in ("CREATE", "UPDATE"):
                      # Note: treat UPDATE as CREATE; it will create a new physical ID,
                      # signalling CloudFormation that it's a replace and the old should be
                      # deleted
                      physicalId, attributes = _create(event["ResourceProperties"])
                      cfnresponse.send(
                          event=event,
                          context=context,
                          responseData=attributes,
                          responseStatus=cfnresponse.SUCCESS,
                          physicalResourceId=physicalId,
                      )
                  else:
                      assert event["RequestType"].upper() == "DELETE"
                      _delete(event["PhysicalResourceId"])
                      cfnresponse.send(
                          event=event,
                          context=context,
                          responseData={},
                          responseStatus=cfnresponse.SUCCESS,
                          physicalResourceId=event["PhysicalResourceId"],
                      )
              except Exception as e:
                  logger.exception("Internal Error")
                  cfnresponse.send(
                      event=event,
                      context=context,
                      responseData=None,
                      responseStatus=cfnresponse.FAILED,
                      reason=str(e))

  PyRequirementsLayer:
    Type: Custom::PipLayer
    Properties:
      ServiceToken: !GetAtt PipLayerLambda.Arn
      Region: !Ref AWS::Region
      LayerName: botolayer
      Packages:
        - boto3>=1.20.44
        - docker

  PclusterManagerEcrPullThroughFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${PclusterManagerEcrPullThroughFunction}

  PclusterManagerEcrPullThroughFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyName: LoggingPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub arn:${AWS::Partition}:logs:*:*:*
        - PolicyName: PullThroughCachePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  # - ecr:CreatePullThroughCacheRule
                  # - ecr:DeletePullThroughCacheRule
                  # - ecr:BatchGetImage
                  - ecr:*
                Resource:
                  - "*"
        - PolicyName: BatchDeletePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ecr:BatchDeleteImage
                  - ecr:ListImages
                  - ecr:DeleteRepository
                Resource: !Sub arn:${AWS::Partition}:ecr:${AWS::Region}:${AWS::AccountId}:repository/*

  PclusterManagerEcrPullThroughFunction:
    Type: AWS::Lambda::Function
    Properties:
      TracingConfig:
        Mode: Active
      MemorySize: 256
      Timeout: 60
      Code:
        ZipFile: |
          import cfnresponse
          import boto3
          import random
          import string
          import logging
          import pprint
          import time
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          import docker

          ecr = boto3.client('ecr')

          def image_match(image_tag, version):
              return f"{version}-" in image_tag or "latest" in image_tag

          def get_image_ids(repository_name, version):
              image_digests = set()
              paginator = ecr.get_paginator('list_images')
              for image_ids in [r['imageIds'] for r in paginator.paginate(repositoryName=repository_name, filter={'tagStatus': 'TAGGED'})]:
                  image_digests.update([image_id['imageDigest'] for image_id in image_ids if image_match(image_id['imageTag'], version)])
              return list({'imageDigest': image_digest} for image_digest in image_digests)

          def create_physical_resource_id():
              alnum = string.ascii_uppercase + string.ascii_lowercase + string.digits
              return ''.join(random.choice(alnum) for _ in range(16))

          def create(properties):
              response_data = {}
              response_data['Message'] = 'Resource creation successful!'
              physical_resource_id = create_physical_resource_id()
              upstream_repository = properties['PublicEcrImageUri']
              upstream_url, public_repo = upstream_repository.split('/')[:2]
              registry_id = properties['AccountId']
              prefix = properties['StackId'].split('/')[-1].split('-')[0]
              version = properties['Version']

              account_id = properties['AccountId']
              region = properties['Region']
              url_suffix = properties['UrlSuffix']

              repository_name = f"{prefix}/{public_repo}/pcluster-manager"
              response_data['PrivateRepository'] = repository_name

              ecr.create_pull_through_cache_rule(
                  ecrRepositoryPrefix=prefix,
                  upstreamRegistryUrl=upstream_url,
                  registryId=registry_id)


              # pull the image so that it is available to the lambda function
              full_repo = f"{account_id}.dkr.ecr.{region}.{url_suffix}/{repository_name}:{version}"
              print(full_repo)

              #token = ecr.get_authorization_token(registryIds=[registry_id])

              #username = 'AWS'
              #password = token['authorizationData'][0]['authorizationToken']
              #registry = token['authorizationData'][0]['proxyEndpoint']

              #docker_client = docker.from_env()
              #docker_client.login(username, password, registry=registry)
              #docker_client.images.pull(full_repo)

              return physical_resource_id, response_data

          def delete(properties):
              registry_id = properties['AccountId']
              prefix = properties['StackId'].split("/")[-1].split("-")[0]
              upstream_repository = properties['PublicEcrImageUri']
              upstream_url, public_repo = upstream_repository.split("/")[:2]
              registry_id = properties['AccountId']
              repository_name = f"{prefix}/{public_repo}/pcluster-manager-awslambda"
              version = properties['Version']

              repository_name = f"{prefix}/{public_repo}/pcluster-manager-awslambda"
              try:
                  image_ids = get_image_ids(repository_name, version)
                  if image_ids:
                      ecr.batch_delete_image(repositoryName=repository_name, imageIds=image_ids)
                      reason = 'Image deletion successful!'
                  else:
                      reason = 'No image found, considering image deletion successful'

              except ecr.exceptions.RepositoryNotFoundException:
                  reason = 'Repository was not found, considering image deletion successful'
              except Exception as exception:
                  response_status = cfnresponse.FAILED
                  reason = 'Failed image deletion with error: {}'.format(exception)

              try:
                  ecr.delete_pull_through_cache_rule(ecrRepositoryPrefix=prefix, registryId=registry_id)
              except ecr.exceptions.PullThroughCacheRuleNotFoundException:
                  reason = 'Cache Rule was not found, considering pull throguh cache deletion successful'
              except Exception as exception:
                  response_status = cfnresponse.FAILED
                  reason = 'Failed image deletion with error: {}'.format(exception)

              try:
                  ecr.delete_repository(registryId=registry_id, repositoryName=repository_name)
              except ecr.exceptions.RepositoryNotFoundException:
                  reason = 'Repository was not found, considering pull throguh cache deletion successful'
              except Exception as exception:
                  response_status = cfnresponse.FAILED
                  reason = 'Failed repository deletion with error: {}'.format(exception)

          def handler(event, context):
              print(event)
              print('boto version {}'.format(boto3.__version__))
              try:
                  response_data = {}
                  status = cfnresponse.SUCCESS
                  if event["RequestType"].upper() in ("CREATE", "UPDATE"):
                    physical_id, response_data = create(event["ResourceProperties"])
                  else:
                    assert event["RequestType"].upper() == "DELETE"
                    delete(event["ResourceProperties"])
                    physical_id = event["PhysicalResourceId"]

                  cfnresponse.send(
                      event=event,
                      context=context,
                      responseData=response_data,
                      responseStatus=cfnresponse.SUCCESS,
                      physicalResourceId=physical_id,
                  )
              except Exception as e:
                  logger.exception("Internal Error")
                  cfnresponse.send(
                      event=event,
                      context=context,
                      responseData=None,
                      responseStatus=cfnresponse.FAILED,
                      reason=str(e))

      Handler: index.handler
      Runtime: python3.9
      Role: !GetAtt PclusterManagerEcrPullThroughFunctionRole.Arn
      Layers:
        - !Ref PyRequirementsLayer

  PclusterManagerEcrPullThroughCache:
    Type: Custom::PclusterManagerEcrPullThroughCache
    Properties:
      ServiceToken: !GetAtt PclusterManagerEcrPullThroughFunction.Arn
      Region: !Ref 'AWS::Region'
      UrlSuffix: !Ref 'AWS::URLSuffix'
      AccountId: !Ref 'AWS::AccountId'
      StackId: !Ref 'AWS::StackId'
      PublicEcrImageUri: !Ref PublicEcrImageUri
      Version: latest

###### DELETE AFTER TESTING
  PclusterManagerFunction:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt PclusterManagerUserRole.Arn
      PackageType: Image
      MemorySize: 512
      Timeout: 30
      TracingConfig:
        Mode: Active
      FunctionName: !Sub
        - PclusterManagerFunction-${StackIdSuffix}
        - { StackIdSuffix: !Select [2, !Split ['/', !Ref 'AWS::StackId']] }
      Code:
        ImageUri: !Sub
          - ${AWS::AccountId}.dkr.ecr.${AWS::Region}.${AWS::URLSuffix}/${Repository}:${Version}
          - Repository: !GetAtt PclusterManagerEcrPullThroughCache.PrivateRepository
            Version: latest
  PclusterManagerUserRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

Outputs:
  PrivateEcrRepository:
    Description: The repository of the pull-through cache.
    Value: !GetAtt PclusterManagerEcrPullThroughCache.PrivateRepository
